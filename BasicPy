"""
A comprehensive Python program demonstrating essential data structures:
- Singly Linked List
- Stack (using list and linked list)
- Queue (using list and linked list)
- Binary Search Tree

Each structure includes basic operations and example usage.
"""

# ---------- Singly Linked List ----------

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        """Add node to end of list"""
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = new_node

    def insert(self, data, pos=0):
        """Insert node at position (default at head)"""
        new_node = Node(data)
        if pos == 0:
            new_node.next = self.head
            self.head = new_node
            return
        curr = self.head
        for _ in range(pos-1):
            if curr.next is None:
                break
            curr = curr.next
        new_node.next = curr.next
        curr.next = new_node

    def delete(self, key):
        """Delete first node with data == key"""
        curr = self.head
        prev = None
        while curr:
            if curr.data == key:
                if prev:
                    prev.next = curr.next
                else:
                    self.head = curr.next
                return True
            prev = curr
            curr = curr.next
        return False

    def display(self):
        """Print all elements"""
        curr = self.head
        elems = []
        while curr:
            elems.append(curr.data)
            curr = curr.next
        print("Linked List:", elems)


# ---------- Stack (List based and Linked List based) ----------

class StackList:
    def __init__(self):
        self.stack = []

    def push(self, data):
        self.stack.append(data)
    
    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        return None
    
    def is_empty(self):
        return len(self.stack) == 0

    def peek(self):
        return self.stack[-1] if not self.is_empty() else None

    def display(self):
        print("Stack (list):", self.stack)

class StackLinkedList:
    def __init__(self):
        self.top = None

    def push(self, data):
        node = Node(data)
        node.next = self.top
        self.top = node

    def pop(self):
        if self.top is None:
            return None
        data = self.top.data
        self.top = self.top.next
        return data

    def is_empty(self):
        return self.top is None

    def peek(self):
        return self.top.data if self.top else None

    def display(self):
        elems = []
        curr = self.top
        while curr:
            elems.append(curr.data)
            curr = curr.next
        print("Stack (linked list):", elems)


# ---------- Queue (List based and Linked List based) ----------

class QueueList:
    def __init__(self):
        self.queue = []

    def enqueue(self, data):
        self.queue.append(data)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def display(self):
        print("Queue (list):", self.queue)

class QueueLinkedList:
    def __init__(self):
        self.front = None
        self.rear = None

    def enqueue(self, data):
        node = Node(data)
        if self.rear is None:
            self.front = self.rear = node
            return
        self.rear.next = node
        self.rear = node

    def dequeue(self):
        if self.front is None:
            return None
        data = self.front.data
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return data

    def is_empty(self):
        return self.front is None

    def display(self):
        elems = []
        curr = self.front
        while curr:
            elems.append(curr.data)
            curr = curr.next
        print("Queue (linked list):", elems)


# ---------- Binary Search Tree (BST) ----------

class BSTNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, data):
        def _insert(root, data):
            if not root:
                return BSTNode(data)
            if data < root.data:
                root.left = _insert(root.left, data)
            else:
                root.right = _insert(root.right, data)
            return root
        self.root = _insert(self.root, data)

    def search(self, key):
        def _search(root, key):
            if not root:
                return False
            if root.data == key:
                return True
            return _search(root.left, key) if key < root.data else _search(root.right, key)
        return _search(self.root, key)

    def inorder(self):
        def _inorder(root):
            return _inorder(root.left) + [root.data] + _inorder(root.right) if root else []
        return _inorder(self.root)

    def display(self):
        print("BST in-order:", self.inorder())


# ---------- Example Usage ----------

if __name__ == "__main__":
    print("\n--- Singly Linked List ---")
    ll = SinglyLinkedList()
    for i in [3, 5, 7]:
        ll.append(i)
    ll.insert(2)
    ll.display()
    ll.delete(5)
    ll.display()

    print("\n--- Stack (List) ---")
    s = StackList()
    for i in [1, 2, 3]:
        s.push(i)
    s.display()
    s.pop()
    s.display()

    print("\n--- Stack (Linked List) ---")
    sl = StackLinkedList()
    for i in [10, 20, 30]:
        sl.push(i)
    sl.display()
    sl.pop()
    sl.display()

    print("\n--- Queue (List) ---")
    q = QueueList()
    for i in [4, 5, 6]:
        q.enqueue(i)
    q.display()
    q.dequeue()
    q.display()

    print("\n--- Queue (Linked List) ---")
    ql = QueueLinkedList()
    for i in [7, 8, 9]:
        ql.enqueue(i)
    ql.display()
    ql.dequeue()
    ql.display()

    print("\n--- Binary Search Tree ---")
    bst = BinarySearchTree()
    for i in [50, 30, 70, 20, 40, 60, 80]:
        bst.insert(i)
    bst.display()
    print("Search 40:", bst.search(40))
    print("Search 100:", bst.search(100))
